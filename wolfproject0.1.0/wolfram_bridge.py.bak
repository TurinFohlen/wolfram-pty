"""
wolfram_bridge.py
-----------------
稳定的 Wolfram-Python 桥梁
"""

import threading
import queue
import random
import time
import re
import os
import logging
import pexpect

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")
log = logging.getLogger("wolfram_bridge")

WOLFRAM_EXEC = os.environ.get("WOLFRAM_EXEC", "math")
WOLFRAM_ARGS = []

PROMPT_RE   = re.compile(r"In\[\d+\]:=")
STARTUP_TIMEOUT  = 60
EVAL_TIMEOUT     = 120
SENTINEL_TIMEOUT = 10

class WolframKernel:
    _instance = None
    _instance_lock = threading.Lock()

    def __new__(cls):
        with cls._instance_lock:
            if cls._instance is None:
                obj = super().__new__(cls)
                obj._initialized = False
                cls._instance = obj
            return cls._instance

    def __init__(self):
        if self._initialized:
            return
        self._initialized = True

        self._child = None
        self._kernel_lock = threading.Lock()
        self._req_queue = queue.Queue()
        self._worker_thread = threading.Thread(target=self._serial_loop, daemon=True)

        self._start_kernel()
        self._worker_thread.start()
        log.info("WolframKernel 单例已初始化")

    def __enter__(self):
        return self

    def __exit__(self, *_):
        self.close()

    def close(self):
        log.info("关闭 Wolfram 内核...")
        self._req_queue.put(None)
        with self._kernel_lock:
            if self._child and self._child.isalive():
                try:
                    self._child.sendline("Quit[]")
                    self._child.expect(pexpect.EOF, timeout=5)
                except Exception:
                    self._child.terminate(force=True)
            self._child = None
        with WolframKernel._instance_lock:
            WolframKernel._instance = None
        log.info("内核已关闭")

    def _start_kernel(self):
        log.info(f"启动内核：{WOLFRAM_EXEC}")
        child = pexpect.spawn(
            WOLFRAM_EXEC,
            WOLFRAM_ARGS,
            encoding="utf-8",
            echo=False,               # pexpect 层面
            timeout=STARTUP_TIMEOUT,
            env=os.environ
        )
        # PTY 层面彻底关闭回显
        child.setecho(False)
        child.waitnoecho()             # 等待生效

        try:
            child.expect(PROMPT_RE, timeout=STARTUP_TIMEOUT)
        except pexpect.TIMEOUT:
            child.terminate(force=True)
            raise RuntimeError("Wolfram 内核启动超时")
        except pexpect.EOF:
            raise RuntimeError(f"内核进程意外退出：{child.before}")

        with self._kernel_lock:
            self._child = child
        log.info("✅ 内核就绪")

    def _restart_kernel(self):
        log.warning("检测到内核异常，尝试重启...")
        with self._kernel_lock:
            if self._child and self._child.isalive():
                self._child.terminate(force=True)
            self._child = None
        time.sleep(1)
        self._start_kernel()
        log.info("✅ 内核已重启")
	def _send_and_wait(self, expr: str) -> str:
	    sentinel = f"__WBRIDGE_{random.randint(100000, 999999)}__"
	    # 创建临时文件，放在内核可访问的目录（建议用 /tmp，proot 内通常可写）
	    import tempfile
	    with tempfile.NamedTemporaryFile(mode='w', suffix='.wl', delete=False, dir='/tmp') as f:
	        f.write(expr + '\n')
	        f.write(f'Print["{sentinel}"]\n')
	        tmp_path = f.name

	    try:
	        with self._kernel_lock:
	            child = self._child
	        if child is None or not child.isalive():
	            raise RuntimeError("内核未运行")

	        child.sendline(f'Get["{tmp_path}"]')

	        # 等待哨兵出现
	        child.expect(re.escape(sentinel), timeout=EVAL_TIMEOUT)
	        raw = child.before

	        # 等待下一个提示符，确保内核就绪
	        child.expect(PROMPT_RE, timeout=SENTINEL_TIMEOUT)

	        # 过滤掉哨兵行，剩下的就是结果
	        result_lines = [line for line in raw.splitlines() if sentinel not in line]
	        return "\n".join(result_lines).strip()
	    finally:
	        # 清理临时文件
	        import os
	        os.unlink(tmp_path)







    @staticmethod
    def _parse_output(raw: str, sent_expr: str = "") -> str:
        lines = raw.strip().splitlines()
        clean = []
        for line in lines:
            stripped = line.strip()
            if not stripped:
                continue
            # 跳过回显：如果行内容与发送的命令相似（前40字符匹配）
            if sent_expr and stripped[:40] in sent_expr:
                continue
            # 跳过哨兵行
            if stripped.startswith("__WBRIDGE_"):
                continue
            clean.append(line)

        # 优先提取 Out[n]= 行
        for line in reversed(clean):
            m = re.match(r"Out\[\d+\]=\s*(.*)", line)
            if m:
                return m.group(1).strip()
        # 否则返回所有剩余行（如纯 Print 输出）
        return "\n".join(clean).strip()

    def _serial_loop(self):
        while True:
            item = self._req_queue.get()
            if item is None:
                log.info("Worker 线程收到退出信号")
                break
            expr, holder = item
            try:
                result = self._send_and_wait(expr)
                holder["result"] = result
                holder["error"] = None
            except Exception as e:
                log.error(f"求值失败：{e}，尝试恢复...")
                holder["result"] = None
                holder["error"] = str(e)
                try:
                    self._restart_kernel()
                except Exception as re_err:
                    log.error(f"重启失败：{re_err}")
            finally:
                holder["event"].set()

    def evaluate(self, expr: str) -> str:
        holder = {"result": None, "error": None, "event": threading.Event()}
        self._req_queue.put((expr, holder))
        holder["event"].wait()
        if holder["error"]:
            raise RuntimeError(holder["error"])
        return holder["result"]

    def batch_evaluate(self, exprs: list[str]) -> list[str]:
        holders = []
        for expr in exprs:
            h = {"result": None, "error": None, "event": threading.Event()}
            self._req_queue.put((expr, h))
            holders.append(h)
        results = []
        for h in holders:
            h["event"].wait()
            if h["error"]:
                results.append(f"ERROR: {h['error']}")
            else:
                results.append(h["result"])
        return results

    def eval_array(self, expr: str):
        try:
            import numpy as np
            import json
        except ImportError:
            raise ImportError("numpy is required for eval_array(). Install with: pip install numpy")
        wrapped = f"ExportString[N[{expr}], \"JSON\"]"
        raw = self.evaluate(wrapped).strip().strip('"').replace('\\"', '"')
        try:
            return np.array(json.loads(raw))
        except Exception as e:
            raise ValueError(f"无法解析为数组：{raw}") from e

    def eval_image(self, expr: str):
        try:
            from PIL import Image as PILImage
        except ImportError:
            raise ImportError("Pillow is required for eval_image(). Install with: pip install Pillow")
        import tempfile
        import os
        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as f:
            tmp = f.name
        try:
            export_expr = f'Export["{tmp}", {expr}, "PNG"]'
            self.evaluate(export_expr)
            img = PILImage.open(tmp)
            img.load()
            return img
        finally:
            if os.path.exists(tmp):
                os.unlink(tmp)


class WolframPipeline:
    def __init__(self, kernel: WolframKernel):
        self._kernel = kernel
        self._steps = []

    def then(self, expr_template: str, output_key: str = "result") -> "WolframPipeline":
        self._steps.append((expr_template, output_key))
        return self

    def run(self, **inputs) -> dict:
        ctx = dict(inputs)
        for i, (template, out_key) in enumerate(self._steps):
            try:
                expr = template.format(**ctx)
            except KeyError as e:
                raise KeyError(f"步骤 {i+1} 模板引用了未定义的键 {e}，当前上下文键：{list(ctx.keys())}") from e
            output = self._kernel.evaluate(expr)
            ctx[out_key] = output
            ctx["result"] = output
        return ctx

    def run_array(self, **inputs):
        try:
            import numpy as np
        except ImportError:
            raise ImportError("numpy required for run_array()")
        ctx = dict(inputs)
        for i, (template, out_key) in enumerate(self._steps[:-1]):
            expr = template.format(**ctx)
            output = self._kernel.evaluate(expr)
            ctx[out_key] = output
            ctx["result"] = output
        last_template, last_key = self._steps[-1]
        expr = last_template.format(**ctx)
        output = self._kernel.eval_array(expr)
        ctx[last_key] = output
        ctx["result"] = output
        return ctx
